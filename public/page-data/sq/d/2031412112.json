{"data":{"featured":{"edges":[{"node":{"frontmatter":{"title":"Dynamic Memory Allocator","cover":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAAErklEQVQ4ywXBa2wTBQAA4Ptr/CM6GMg2thX6GG3X5/V97V17ba/X6/Pauz7X9ra+X2tp163rHowx9iB0ww2GkTfDwAJDfkgcImow/BF/GDXhh8RoAgkhGuU/fh8ggowKC67GCL3LayRpkz+MUmE0EEHpCEzSBrdP5/AoUJsQQrhKHUci72EPHDrC62Nz+9hsQKAxyE1WldUOEW7Y5bWQflsgaB+KY6GIjQ6iVFDvJkEUM2Fmt90EQkg0k4XtjgGZ7CgIAkdVeonBpLTiMOHIFzPbW+dKlZyVDjqiMTtNm3yUzumRwGafF89HnHjQd3ylmaiMyDEbVywDjqr1YoNJZsIyo8VHX9/66emde/euhHIFR5ypjI60ZqpjC8ejxbyJ9Ecoh3t8rLS9Fb90XmC19bJ5AE8BCXWwCndrrPAI41pemgiW/EQyGiyMnpgt3bq2cqY9u7DYDKeGm5U44nDBzWVldpQlkvKVaoCr0IFmDETx2OlZql2WpQnm5mL2/EqqcaxxZhprDZkZn9aDaCJ2bCgBmjFvIhSK+aWoqZcnANhyrTY5rPDThbVT37z9ffefP77998+Vzy+0N5Y3r66tPrpeuf/pie9uXnh6v3GqlZ2o1i6dYy6u4/UaVygGxAgmtuCuAB1NeeJnxta+vBFppKoz9fp0Y2qu6YsHFravLu9smSl7spwYnSgX6mUsV4BJki8DAZ7aqMIcU+PZnx+uxZPuPhEH1CkWTrayrbqhNRbYWktcXkKGfEoCmm7PGT0ER8gTKoQwQfBBNcBRI1IjFovTl89ON+sZmnK6h4f0lbz7s9Xbb/668euz2cW5ZjVTb1UTpTThxyEHbA55MpUMCEHAIIJXx6szS+NoxJhgSP9k1bnZXv/t2Y//vdx5sJOeasHpgjfJKN2olEQL06PFsYKLtGMuK0/AAw4PylHUUKsliazLOpOYePLwyds3D148r52crlWz9dGkt9VCNzfmv7+79MOuLZcMDfnCiaBEOthz8ADQOzD4wfvv7e/cy+o/BHnghSvtzPl17dKi/9pFdeWYOJcqfXHnxbt3289/CcxMjhQZl9fKYvUe6NjT29cPDCJ2iUbP6tqvEXM8VhC1abCQM700t/v369uvX95982rn1avU5llryMaV8i0OqwSUCGRyoVrPlWuBAZ0lkU1fW20EHXoxp9us40/WopVG0VbOrT9+3N59IAlTIh0I2Yx6v4+jgVh8PkZH/MmsGnMBahcVK+THmxUyFqU86Feb2fZyVqCRRGMusjQyaNZJIVBhxzBmREW4jCSNBBkr7cMddo0VBiQmuwjBfAlmcq7JFFOpBGlU8hCNSMTrg0ywTKXoYvX1DAzw5CASiFLHppwjee/qJ+Xrm96VeYCvRfQ+OjRTi87XzOm0xhsOD4chSLm3q7vjoz2dHR92d3epYBj1kgZ/KFAqBSKUIpHWzJ3tUcOAQG8W6owqJm9Z3FBQcRXuRHwBppTLlDMCqaS7/zBXbaBSw8VazuAgiLFa6OSkqZzv6On9uHMfwJYoB5TafQe793R28bWw3ILLLLgSd1KxqJH0i1GbyGAmTswPbyyjzfEjMKaLMRwd3NN/+BDryP83W6+iPjRxzwAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/e6f632d7a4e6c9093cd71d5c722cc6de/8d33e/Dynamic_Memory_Allocator_Image.png","srcSet":"/static/e6f632d7a4e6c9093cd71d5c722cc6de/41cc8/Dynamic_Memory_Allocator_Image.png 175w,\n/static/e6f632d7a4e6c9093cd71d5c722cc6de/88e48/Dynamic_Memory_Allocator_Image.png 350w,\n/static/e6f632d7a4e6c9093cd71d5c722cc6de/8d33e/Dynamic_Memory_Allocator_Image.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/e6f632d7a4e6c9093cd71d5c722cc6de/00dc1/Dynamic_Memory_Allocator_Image.avif 175w,\n/static/e6f632d7a4e6c9093cd71d5c722cc6de/7e92b/Dynamic_Memory_Allocator_Image.avif 350w,\n/static/e6f632d7a4e6c9093cd71d5c722cc6de/2c516/Dynamic_Memory_Allocator_Image.avif 700w","type":"image/avif","sizes":"(min-width: 700px) 700px, 100vw"},{"srcSet":"/static/e6f632d7a4e6c9093cd71d5c722cc6de/51bad/Dynamic_Memory_Allocator_Image.webp 175w,\n/static/e6f632d7a4e6c9093cd71d5c722cc6de/6cac9/Dynamic_Memory_Allocator_Image.webp 350w,\n/static/e6f632d7a4e6c9093cd71d5c722cc6de/ec00d/Dynamic_Memory_Allocator_Image.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":700}}},"tech":["C (gcc)","Make","GNU Debugger (GDB)","Valgrind","Bash / Linux CLI","Custom Test Harness"],"github":"https://gitfront.io/r/suhaas55/uziwxGhpREse/MemAlloc/","external":"https://gitfront.io/r/suhaas55/uziwxGhpREse/MemAlloc/","cta":null},"html":"<p>I built a custom dynamic memory allocator in C that implements my own versions of malloc, free, and realloc within a single mm.c file. Using GCC and a Makefile on Linux, I automated compilation and testing with a trace-driven harness that exercises edge cases and varied allocation patterns. To guarantee correctness and performance, I developed a heap consistency checker—leveraging GDB for in-depth debugging and Valgrind to detect leaks and alignment errors—ensuring proper coalescing of free blocks and strict 16-byte alignment. This project deepened my understanding of low-level memory management, pointer arithmetic, and systems-level optimizations, resulting in an allocator that is both fast and space-efficient.</p>"}},{"node":{"frontmatter":{"title":"Concurrency Synchronization Channel","cover":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACVklEQVQozyWSSVPaYACG+aVee+ulMz146aDU9qQl27cmhCVA2CQBEoSoUQJEFCj7DqJSZdSZ/oQOdea9PvM+h8cjCARCEUIRIREjCRM5ncxo6Ww4FItFk7FoMiAr6VTmNHUqikGERARFACkAVBCIBwDK85hhAMsijOVyRn+fTya/W/GoWsiZulawc+b7bDrttGUpRIjMcYhhoCCQHSzwCEJqnZXarqsmM7e6sTJLh16fKAbqTv36yulb9r1R+uE7Oj5mzLwxbLcso8hzSBCwh+FQQUn87Xdd+1ISA3pauz2zVEW9uqpO5+vJbN2oN26LlqrEFUVd29cPrWZYDrIMAIB4OIFo4dg8X/x5cMQwQtEsOZXqanF/Pxm+XkhvtjwfDcfTec2p6boxMErlQPjL132OBRCKHggolUL5tJbLaI5THw1Gk+GoP5ovTfoE9kzvnpUIjSfzYW/Q6/YrlXpJL8SicTkQ2T3zAlEj8UW387KYVS7tXre/Wqw2z68Prnn36xO//9m1L/5snifjaafd6dVv3tbLZrVGibyDWQ4XIuqbUwtjenzir1ZqbdftNRovz9vtcrxZTl+2r6vZ7HGxqDr1x/JlK28cHP5g/PxOmxeIiCQnkQEnHMRSo1Jzy6VUMGhb55vNdr1+Wjbb236vWa3Eoqqjm4asfDs4YlkIAPUAgfA8ZnlMiRwJxy6KlqVpPq8vm86271o3jbvB+fUiX/R5v/v9fFhRIaDwfyECj3cwhPRjGImUBkNyJBRUUslTPZvXsvmkms5FEwRSTGSMJLTLi3wU9g/Ap8byDzNCSgAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/41c78653518c21d76935510db472019f/16a35/Concurrency_Channel_Image.png","srcSet":"/static/41c78653518c21d76935510db472019f/9a130/Concurrency_Channel_Image.png 175w,\n/static/41c78653518c21d76935510db472019f/47c72/Concurrency_Channel_Image.png 350w,\n/static/41c78653518c21d76935510db472019f/16a35/Concurrency_Channel_Image.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/41c78653518c21d76935510db472019f/dae43/Concurrency_Channel_Image.avif 175w,\n/static/41c78653518c21d76935510db472019f/69c10/Concurrency_Channel_Image.avif 350w,\n/static/41c78653518c21d76935510db472019f/fa1f8/Concurrency_Channel_Image.avif 700w","type":"image/avif","sizes":"(min-width: 700px) 700px, 100vw"},{"srcSet":"/static/41c78653518c21d76935510db472019f/5d873/Concurrency_Channel_Image.webp 175w,\n/static/41c78653518c21d76935510db472019f/853c6/Concurrency_Channel_Image.webp 350w,\n/static/41c78653518c21d76935510db472019f/81f83/Concurrency_Channel_Image.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":393}}},"tech":["C (gcc)","POSIX Threads","Make","GNU Debugger (GDB)","Valgrind","Bash / Linux CLI","Custom Test Harness"],"github":"https://gitfront.io/r/suhaas55/Pf5APUKi8ZEV/Concurrency/","external":"https://gitfront.io/r/suhaas55/Pf5APUKi8ZEV/Concurrency/","cta":null},"html":"<p>I built a multi‐threaded channel in C to safely pass messages between concurrent senders and receivers. Leveraging POSIX threads and a ring‐buffer queue, it supports both blocking and non‐blocking send/receive modes. A Makefile automates compilation and a trace‐driven test harness exercises edge cases—full‐buffer sends, empty‐buffer receives, and concurrent access patterns. I used GDB for step‐through debugging and Valgrind for memory/race‐condition checks, ensuring robust synchronization and zero data corruption. This deep dive into threading and synchronization vastly improved my understanding of systems‐level concurrency and performance tuning.</p>"}}]}}}