{"expireTime":9007201002007610000,"key":"transformer-remark-markdown-html-c160e5f2aed6e1924c0bc02e2ee7dba5-gatsby-remark-external-linksgatsby-remark-imagesgatsby-remark-code-titlesgatsby-remark-prismjs-","val":"<p>I built a multi‐threaded channel in C to safely pass messages between concurrent senders and receivers. Leveraging POSIX threads and a ring‐buffer queue, it supports both blocking and non‐blocking send/receive modes. A Makefile automates compilation and a trace‐driven test harness exercises edge cases—full‐buffer sends, empty‐buffer receives, and concurrent access patterns. I used GDB for step‐through debugging and Valgrind for memory/race‐condition checks, ensuring robust synchronization and zero data corruption. This deep dive into threading and synchronization vastly improved my understanding of systems‐level concurrency and performance tuning.</p>"}