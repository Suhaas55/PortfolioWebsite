{"expireTime":9007201002007610000,"key":"transformer-remark-markdown-html-ast-c160e5f2aed6e1924c0bc02e2ee7dba5-gatsby-remark-external-linksgatsby-remark-imagesgatsby-remark-code-titlesgatsby-remark-prismjs-","val":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I built a multi‐threaded channel in C to safely pass messages between concurrent senders and receivers. Leveraging POSIX threads and a ring‐buffer queue, it supports both blocking and non‐blocking send/receive modes. A Makefile automates compilation and a trace‐driven test harness exercises edge cases—full‐buffer sends, empty‐buffer receives, and concurrent access patterns. I used GDB for step‐through debugging and Valgrind for memory/race‐condition checks, ensuring robust synchronization and zero data corruption. This deep dive into threading and synchronization vastly improved my understanding of systems‐level concurrency and performance tuning.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":656,"offset":656}}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":656,"offset":656}}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":2,"column":656,"offset":656}}}}